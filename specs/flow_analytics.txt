Please implement a new function Journey.Insights.flow_analytics/3 that provides business-focused analytics for understanding customer behavior through Journey graphs.

Function Signature

def flow_analytics(graph_name, graph_version, opts \\ [])

Parameters & Options

- graph_name - String, the graph name to analyze
- graph_version - String, the graph version to analyze
- opts - Keyword list with options:
  - :include_executions - :all | :archived | :active (default: :active)
  - :flow_ends_here_after - Duration after which we consider a flow "ended" if no activity (default: 1 day)

Expected Return Structure

%{
  # Graph metadata
  graph_name: graph_name,
  graph_version: graph_version,
  analyzed_at: DateTime.utc_now() |> DateTime.to_iso8601(),

  # Execution-level analytics
  executions: %{
    count: 2847,
    duration_median_seconds_to_last_update: 1234,
    duration_avg_seconds_to_last_update: 1456
  },

  # Per-node customer journey metrics
  node_stats: %{
    nodes: [
      %{
        node_name: :full_name,
        node_type: :input,  # or :compute, :mutate, etc.
        reached_count: 2840,      # executions that set this value
        reached_percentage: 99.7, # vs total executions in scope
        average_time_to_reach: 12, # seconds from execution start
        flow_ends_here_count: 23,  # executions where this was last activity before flow_ends_here_after
        flow_ends_here_percentage_of_all: 0.8,      # vs all executions
        flow_ends_here_percentage_of_reached: 0.81  # vs executions that reached this node
      }
      # ... more nodes
    ]
  }
}

Implementation Notes

1. Focus on business metrics, not technical details - This should answer "where do customers drop off?" not "which computations failed?"
2. Use existing Journey patterns - Follow the query and data structure patterns from Journey.Insights.fetch_execution_stats/2 and fetch_computation_stats/2, but focus on the Value table instead of Computation table
3. Handle the flow ending logic - An execution's flow "ends" at a node if that node was the last one to be updated (highest set_time) and flow_ends_here_after time has passed since then. Use subqueries to find the max(set_time) per execution_id
   - All timestamps in Journey are Unix seconds (integers)
   - Convert flow_ends_here_after duration to seconds for comparison: System.system_time(:second) - duration_seconds
   - Use existing Journey timestamp patterns with System.system_time(:second)
4. Include all node types - Input, compute, mutate, schedule nodes - any node that can have a value set
5. Filter executions properly - Respect the :include_executions option (active vs archived vs all)
   - :active means WHERE archived_at IS NULL
   - :archived means WHERE archived_at IS NOT NULL
   - :all includes both active and archived executions
6. Calculate percentages correctly - reached_percentage is vs total executions in scope, flow_ends_here_percentage_of_* uses the appropriate denominator
7. Don't implement step-to-step conversions - We're leaving that to the application layer since Journey doesn't know the intended customer flow sequence
8. Query Performance - Use JOINs between Execution and Value tables following existing patterns in Journey.Insights.status/0. Consider query performance for large datasets
9. Database Performance - Check existing indexes during implementation. The queries will heavily use graph_name/graph_version filtering on executions and execution_id joins with values. Consider adding indexes if query performance is poor during testing

Database Queries Needed

You'll likely need to query:
- Journey.Execution table for execution counts and timing
- Journey.Execution.Value table for node reach data and timing
- Join these appropriately and use the existing Journey query patterns

Implementation & Testing

Follow CLAUDE.md guidelines:
- Run `make validate` before declaring complete
- Run `make test-performance` to assess query performance impact  
- Use `redact/2` helper in tests for masking dynamic values (IDs, timestamps)
- Update `mix.exs` coverage threshold if coverage increases
- Write idiomatic Elixir following existing Journey.Insights patterns
- Include error handling following Journey.Insights.status/0 pattern (rescue DBConnection.ConnectionError)

Please add basic tests covering:
- Different :include_executions options
- Percentage calculations
- Flow ending logic
- Multiple graph versions

This function should help product managers understand customer behavior patterns and identify where users drop off in their Journey-powered applications.
